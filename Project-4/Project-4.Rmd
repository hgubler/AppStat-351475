---
title: "Project-4: U.S Presidential Elections"
author: "Hannes"
date: "2023-04-05"
output: 
  bookdown::html_document2:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
```

# Introduction

The U.S. Presidential elections are one of the most significant political events in the world and draw attention from all across the globe. The elections, which take place every four years, determine the president of the United States for the next four years. In contrary to most countries in this world, there is not a single nationwide election. Instead, it is a series of separate state-level elections, which then are combined to determine the winner. Each state has a certain number of "electoral votes" that are (more or less) based on its population and the candidate with the most votes in a given state wins all of that state's electoral votes.

In this report, we explore the data on U.S. Presidential elections between 1948 and 1992, focusing on the two-party vote for the Democratic and Republican candidates in each state and year. We try to model the share of democratic votes in a given state and year first with a linear model and later with a linear mixed model. By analyzing the data, we aim to identify crucial factors that lead to electoral success in the United States. Furthermore we investigate how we can apply linear mixed model to the data to overcome the independence assumption of the linear model.

# Data Explanation

To model the share of democratic votes in a given state and year, we have the following variables available

* `dvote` - the outcome variable, the Democratic party candidate's share of the vote in the given state and year
* `year` - specifies the year of the election
* `state` - specifies the state of the corresponding outcome variable
* `evotes` - specifies the number of electoral votes for a given state

Additionally we have the nationwide variables

* `dvote_poll` - the nationwide Democratic party candidate's share of the vote in the September poll
* `dapprove_inc` - the nationwide presidential approval in the July poll (negative values for Republic presidents and positive values for Democratic presidents)
* `dapprove_presinc` - same as `dapprove_inc` but equals 0 if the current president is not running for a re-election
* `gnp_growth_inc` - the statewide GNP growth in the second quarter (positive values if the incumbent president is a Democrat and negative if the incumbent president is a Republican)

Furthermore we have the state wide variables

* `dvote_last` - the Democratic party candidate's share of the last election given state and year (as a deviation from corresponding national vote)
* `dvote_last2` - the Democratic party candidate's share two elections ago given state and year (as a deviation from corresponding national vote)
* `home_state` - the home state of the presidential candidate (+1 if the corresponding state is the home state of the Democratic candidate and -1 if the corresponding state is the home state of the Republican candidate)
* `home_state_vice` - the home state of the vice-presidential candidate (+1 if the corresponding state is the home state of the Democratic vice candidate and -1 if the corresponding state is the home state of the Republican vice candidate)
* `dmajor_leg` - the democratic majority in the state legislature (positive values if the Democrats had a majority compared to the Republicans and negative values if the Republicans had a majority compared to the Democrats)
* `econ_growth_inc` - the state economic growth in the past year (positive values if the incumbent president is a Democrat and negative if the incumbent president is a Republican)
* `state_ideology` - a measure for the state ideology (same value in every year) (positive values if ideology is more Democratic and negative values if ideology is more Republic)
* `ideology_comp` - ideological compatibility of a given state with the candidates 
* `cath_1960` - proportion of Catholics in 1960 compared to U.S. average and 0 in any other year (1960 had a Catholic presidential candidate)

Lastly we have the regional variables 

* `south` - south indicator
* `south_1964` - south indicator in 1964
* `deep_south_1964` - deep south indicator in 1964
* `new_england_1964` - New England indicator in 1964
* `new_england_1972` - New England indicator in 1972
* `west_1976` - west indicator in 1976

TBD: Maybe dont mention evotes if never use it.

The year 1964 was special because the Democratic candidate was able to completely dominate the elections, also in the south but with an exception of the deep south states. The other regional variables (`south`, `new_england_1972`, `west_1976`) are there to adjust for known and expected outliers (very unusual results in certain states and years) instead of removing them from the data.

In our analysis we will treat year, state as well as all the regional variables as factors, while the remaining variables will be treated as numerical. Furthermore we will add an additional factor `region` to the dataset dividing the states in the regions "Northeast", "South", "Midwest" and "West. Lastly we remove all the observation with missing values from our data.

```{r preprocessing}
library("readr") # to load data
library("tidyverse")
library("ggpubr") # for ggarrange
library("car") # type 2 anova
library("knitr") #Â to print tables
library("lme4") # for mixed models
data <- read_table("4_US_elections.txt")
data = data %>% select(-constant) # remove manually added intercept
# change mentioned variables to factors
data = data %>% 
  mutate(year = as.factor(year),
                       state = as.factor(state), 
                       r1 = as.factor(r1), 
                       r2 = as.factor(r2), 
                       r3 = as.factor(r3), 
                       r4 = as.factor(r4), 
                       r5 = as.factor(r5), 
                       r6 = as.factor(r6), )

# rename the variables
data = data %>% 
  rename(dvote = Dvote,
         dvote_poll = n1,
         dapprove_inc = n2,
         dapprove_presinc = n3,
         gnp_growth_inc = n4,
         dvote_last = s1,
         dvote_last2 = s2,
         home_state = s3,
         home_state_vice = s4,
         dmajor_leg = s5,
         econ_growth_inc = s6,
         state_ideology = s7,
         ideology_comp = s8,
         cath_1960 = s9,
         south = r1,
         south_1964 = r2,
         deep_south_1964 = r3,
         new_england_1964 = r4,
         new_england_1972 = r5,
         west_1976 = r6)

# create a region variable
northeast = c(7, 8, 19, 20, 21, 29, 30, 32, 38, 39, 45, 48)
south = c(1, 4, 9, 10, 17, 18, 24, 33, 36, 40, 42, 43, 46)
midwest = c(13, 14, 15, 16, 22, 23, 25, 27, 34, 35, 41, 49)
west = c(2, 3, 5, 6, 11, 12, 26, 28, 31, 37, 44, 47, 50)

data$region <- ifelse(data$state %in% northeast, "northeast",
                      ifelse(data$state %in% south, "south",
                             ifelse(data$state %in% midwest, "midwest",
                                    ifelse(data$state %in% west, "west", NA))))
data = data %>% mutate(region = as.factor(region))
data = na.omit(data)
```

# Linear Model

For our first linear model, we certainly want to include `state` to predict `dvote`. Since `state` is a factor variable, we can't include the factor `region` to the same model since it would make the design matrix singular. The same goes for `state_ideology`, which does not change over the years and hence is the same number in each for two observations from the same state. Similarly, we want to include the factor `year` in our first model, which will not allow us to use any of the nationwide variables, since a nationwide variable takes the same value for all observations of one year.
So our linear model uses the predictors `dvote_last`, `dvote_last2`, `home_state`, `home_state_vice`, `dmajor_leg`, `econ_growth_inc`, `ideology_comp`, `cath_1960`, `south`, `south_1964`, `deep_south_1964`, `new_england_1964`, `new_england_1972` and `west_1976` to model the response `dvote`. First we look at the type 2 anova test for our linear model, which compares for each coefficient the full model vs the model with all predictors but not the one corresponding to the specific coefficient.

```{r anova}
m0 = lm(dvote ~ . - evotes - region - state_ideology - dvote_poll - dapprove_inc
        - dapprove_presinc - gnp_growth_inc, data = data)
# perform type 2 anova and print results in a table
anova = Anova(m0, type = 2)
kable(anova[1:16, ], digits = 3, caption = "Type 2 anova for the linear model, comparing for each coefficient the full model with the full model excluding the predictor from that coefficient.")
```
Except `ideology_comp` all the coefficients seem to be important, so we keep all the predictors from before but remove `ideology_comp` from our model.

Next we look at the residuals vs fitted values and normal Q-Q plots of our linear model.

```{r diagnostics, fig.width=7, fig.height=3.5, fig.cap="Residuals vs fitted values (left) and normal Q-Q plot (right) of our linear model."}
# fit the same model as before but exclude ideology_comp
m1 = lm(dvote ~ . - evotes - region - state_ideology - dvote_poll - dapprove_inc
        - dapprove_presinc - gnp_growth_inc - ideology_comp, data = data)
# create a data frame that contains residuals, standardized residuals and fitted values for plots

data_res = data
data_res$residuals = resid(m1)
data_res$std_residuals = rstandard(m1)
data_res$fitted = m1$fitted.values
# create residuals vs fitted values plot
res_vs_fit = ggplot(data_res, aes(x = fitted, y = residuals)) + 
  geom_point() + 
  labs(x = "fitted values", y = "residuals") + 
  ggtitle("Residuals vs Fitted Values")
# create qq plot
qq_plot = ggplot(data_res, aes(sample = std_residuals)) +
  stat_qq() + 
  stat_qq_line() + 
  labs(x = "theoretical quantiles", y = "standardized residuals quantiles") + 
  ggtitle("Normal Q-Q Plot")
# plot residuals vs fitted values (left) and qqplot (right)
ggarrange(res_vs_fit, qq_plot, ncol = 2, nrow = 1)
```
The normal Q-Q plot looks fine with only slight abbreviations in the tails, so the normality looks passable. Additionally we do not observe a clear pattern in the residuals vs fitted values plot, suggesting that the independence assumption could hold. However it is still possible that we have dependence of observations inside specific groups, for example observations from the same year or the same region could influence each other.

```{r onelvlgroup, fig.height=3.5, fig.width=9, fig.cap="Boxplots of the residuals of our linear model grouped by year (left) and grouped by region (right)."}
# create boxplots of residuals grouped by region
year_res_plot = ggplot(mapping = aes(y = residuals, col = year), data = data_res) + 
  geom_boxplot() + 
  ggtitle("Boxplots of Residuals by Year")
# create boxplots of residuals grouped by region
region_res_plot = ggplot(mapping = aes(y = residuals, col = region), data = data_res) +
  geom_boxplot() + 
    ggtitle("Boxplots of Residuals by Region")
# arrange the two plots in a 1x2 grid
ggarrange(year_res_plot, region_res_plot, nrow = 1, ncol = 2)
```

The residuals still look acceptable as we do not observe groups that substantially exceed the region around zero. Another point to consider is the dependence of observations from the same year and the same region. Possibly in a specific year, states in the same region tend to influence each other.

```{r twolvlgroup, fig.height=5, fig.width=9, fig.cap="For each region the corresponding plot shows boxplots of the residuals corresponding to the same year."}
data_northeast = data_res[data_res$region == "northeast", ]
data_south = data_res[data_res$region == "south", ]
data_midwest = data_res[data_res$region == "midwest", ]
data_west = data_res[data_res$region == "west", ]
northeast_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_northeast) +
  geom_boxplot() + 
  ggtitle("Northeast Residuals by Year")
south_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_south) +
  geom_boxplot() +
  ggtitle("South Residuals by Year")
midwest_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_midwest) +
  geom_boxplot() +
  ggtitle("Midwest Residuals by Year")
west_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_west) +
  geom_boxplot() +
  ggtitle("West Residuals by Year")
#grid.arrange(northeast_res_plot, south_res_plot, midwest_res_plot, west_res_plot, ncol = 2)
ggarrange(northeast_res_plot, south_res_plot, midwest_res_plot, west_res_plot, 
          ncol = 2, nrow = 2, common.legend = TRUE, legend = "right")
```

Now we observe a grouping effect. It looks like the distribution of the residuals within one region from different years differ from each other. This suggests that observations within one region and year may be dependent, violating our assumptions for the linear model. Therefore it could be useful to model the data with a linear mixed model, where we can allow for dependency between certain observations.

# Linear Mixed Model

The Linear Mixed Model is an extension of the linear model. We define it as
$$
Y = X\beta + Z b + \epsilon, \quad b \sim N_q(0,C), \quad \epsilon \sim N_n(0, \sigma^2I_n)
$$
where $X \in \mathbb{R}^{n\times p}$ and $Z \in \mathbb{R}^{n\times q}$ are known design matrices, $\beta \in \mathbb{R}^p$ are fixed parameters (effects), $b \in \mathbb{R}^q$ are random effects (independent of $\epsilon$) and $Y \in \mathbb{R}^n$ is the response. So the parameters in a Linear Mixed model are $\beta, C$ and $\sigma^2$. They are estimated either by using maximum likelihood (ML) or restricted maximum likelihood (REML). The inclusion of the random effect $b$ in the model allows for the modeling of the correlation structure among the observations. Specifically, the random effect $b$ captures the deviation of the observations within a group from the overall population mean (fixed effect). Moreover the covariance matrix $C$ of $b$ can allow for correlation between different groups.

As observed in Figure (\@ref(fig:twolvlgroup)) we would like to allow for dependency between observations from the same year and region. So we add a random effect of the interaction between `year` and `region` to our linear model from the section before. Furthermore we also add a random effect to `year` itself as it intuitively makes sense to allow for correlation of observations from the same year. In the R syntax, we add the term `(1|year/region)` to our linear model and fit it with the lmer function from the lme4 library. We have `(1|year/region) = (1|year) + (1|year:region)`, which adds a random intercept for `year` and regions within years `region:year` to our model.

```{r mixedm0}
mixed_m0 = lmer(dvote ~ . -  evotes - region - year + (1|year/region), data = data)
data_res_mixed = data_res
data_res_mixed$residuals = resid(mixed_m0)
data_northeast_mixed = data_res_mixed[data_res_mixed$region == "northeast", ]
data_south_mixed = data_res_mixed[data_res_mixed$region == "south", ]
data_midwest_mixed = data_res_mixed[data_res_mixed$region == "midwest", ]
data_west_mixed = data_res_mixed[data_res_mixed$region == "west", ]
northeast_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_northeast_mixed) +
  geom_boxplot() + 
  ggtitle("Northeast Residuals by Year")
south_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_south_mixed) +
  geom_boxplot() +
  ggtitle("South Residuals by Year")
midwest_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_midwest_mixed) +
  geom_boxplot() +
  ggtitle("Midwest Residuals by Year")
west_res_plot = ggplot(mapping=aes(y=residuals, col=year), data = data_west_mixed) +
  geom_boxplot() +
  ggtitle("West Residuals by Year")
#grid.arrange(northeast_res_plot, south_res_plot, midwest_res_plot, west_res_plot, ncol = 2)
ggarrange(northeast_res_plot, south_res_plot, midwest_res_plot, west_res_plot, 
          ncol = 2, nrow = 2, common.legend = TRUE, legend = "right")
```



