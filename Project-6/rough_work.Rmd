---
title: "rough_work"
author: "Hannes"
date: "2023-05-10"
output: 
  bookdown::html_document2:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
```

# Data

```{r}
library("readr")
library("tidyverse")
data = read_csv("data/covid_deaths_usafacts.csv")

# remove unneeded columns
data = data %>%
  dplyr::select(-StateFIPS, -countyFIPS, -"County Name")
# group data by state instead of by country
data = data %>%
  group_by(State) %>%
  summarize_all(sum)
```

plot deaths per day from 22.01.2020 to 29.04.2023 nationwide

```{r}
# nationwide data 
nation_data = data %>%
  dplyr::select(-State)
nation_data = colSums(nation_data)
# create data such that we have deaths per day instead of cumulative deaths over time
diff_nation_data = c(nation_data[1], diff(nation_data))
plot_data = as.data.frame(diff_nation_data)
plot_data$time = 1:length(diff_nation_data)
ggplot(data = plot_data, aes(x = time, y = diff_nation_data)) + 
  geom_line() + 
  scale_x_continuous(breaks = c(1, 183, 368, 550, 735, 917, 1102), 
                     labels = c("22.01.2020", "22.07.2020", "22.01.2021",
                                "22.07.2021","22.01.2022", "22.07.2022", 
                                "22.01.2023"))
```
See that its very wiggly and some times even negative number of deaths per day, which is certainly not possible. This phenomenon occurs because, when counting the Covid deaths over time, certain death cases from a particular day may be subtracted due to counters believing they had overcounted on previous days. As a result, this can lead to a negative count of deaths on a given day.

To tackle this issue we apply smoothing to our data using kernel methods with a Gaussian kernel and bandwidth 7 (where the days are numerated from one to $n$ where $n$ is the total number of days in our data). We apply smoothing to each state separately.
```{r smoothing}
y = as.matrix(data[,-1])
for (i in 1:nrow(y)) {
  smoothed_states = ksmooth(x = 1:ncol(y), 
        y = y[i, ],
        bandwidth = 7,
        kernel = "normal")
  y[i, ] = smoothed_states$y
}
smoothed_data = as.data.frame(y)
smoothed_data$state = data$State
nation_data = colSums(y)
# create data such that we have deaths per day instead of cumulative deaths over time
diff_nation_data = c(nation_data[1], diff(nation_data))
plot_data = as.data.frame(diff_nation_data)
plot_data$time = 1:length(diff_nation_data)
ggplot(data = plot_data, aes(x = time, y = diff_nation_data)) + 
  geom_line() + 
  scale_x_continuous(breaks = c(1, 183, 368, 550, 735, 917, 1102), 
                     labels = c("22.01.2020", "22.07.2020", "22.01.2021",
                                "22.07.2021","22.01.2022", "22.07.2022", 
                                "22.01.2023"))
```
This already looks better and we got rid of negative values. So from now on we work with the smoothed values for the death numbers. 



We perform PCA on logarithm of cumulative Covid deaths. TBD: explain why take logarithm. To take the log of the data, we start our data only from 03.04.2023, the date when in every state we have at least one covid death and hence we wont take log(0). Furthermore rescale the data such that we have number of deaths by capita in each state to bring the numbers on the same scale

```{r cumulativedeath}
smoothed_data = smoothed_data[, 73:ncol(smoothed_data)]
populations = c(733583, 5074296, 3045637, 7359197, 39029342, 5839926, 3626205,
                671803, 1018396, 22244823, 10912876, 1440196, 3200517, 1939033,
                12582032, 6833037, 2937150, 4512310, 4590241, 6981974, 6164660, 
                1385340, 1385340, 5717184, 6177957, 2940057, 1122867, 
                10698973, 779261, 1967923, 1395231, 9261699, 2113344, 3177772 ,19677151, 
                11756058, 4019800, 4240137, 12972008, 1093734, 5282634, 909824, 
                7051339, 30029572, 3380800, 8683619, 647064, 7785786, 5892539,
                1775156, 581381)
for (i in 1:nrow(smoothed_data)) {
  smoothed_data[i, ] = as.numeric(smoothed_data[i, ]) / populations[i]
}
smoothed_data[, -ncol(smoothed_data)] = sapply(smoothed_data[, -ncol(smoothed_data)], log) 
```


```{r PCA}
svd_mat = as.matrix(smoothed_data[, -ncol(smoothed_data)])
# Center matrix by columns
svd_mat_centered = scale(svd_mat, center = TRUE, scale = FALSE)
svd = svd(svd_mat_centered)
eig_val = svd$v
par(mfrow = c(1,3))
x = 1:nrow(eig_val) 
plot(x, eig_val[, 1], type = "l")
plot(x, eig_val[, 2], type = "l")
plot(x, eig_val[, 3], type = "l")
```




